# 排序 (sort)





## 总结



![](http://m.qpic.cn/psc?/V13mdl0c1ilKRz/w47sCHZ1vIeYe.9hWkknXXcBL2JtC2xn7Q*G7bb2Vj9.2HJ2T5AAczIidBxxSm.3kIHAlBcDjfvr1EVzESDcHQ!!/b&bo=UgY4BAAAAAARB1g!&rf=viewer_4)













## 比较函数

- `compareFunction(a, b)` 返回值小于0, 那么a的索引小于b的索引
- `compareFunction(a, b)` 返回值大于0, 那么a的索引大于b的索引
- 等于0, a,b之间关系不能保证



## 选择排序 (selection sort)

**在第i次迭代中, 找出剩余部分的最小值, 并与索引i的元素交换**



**比较次数**

在所有情况下均为: `N^2 / 2`



**交换次数**

N次, 每次迭代只需交换一次, 一共N次迭代



- 选择排序是**原位**的算法
- **不是稳定**的算法





## 插入排序 (insertion sort)

**在第i次迭代中, 依次与`a[i]`之前的大数进行交换 (保证`a[i]`之前的数为sorted状态)**



**比较次数**

- 最多`(N * N) / 2` (完全逆序的情况下)
- 最少`N - 1` (完全顺序, 每次迭代只需要比较一次)
- 平均`(N * N) / 4` 



**交换次数**

最多`N - 1`, 最少`0`次 (每次迭代可能交换1次或者0次)



- 插入排序是**原位**的算法
- **稳定**的算法





## 希尔排序 (shellsort )

**插入排序的升级版: 插入排序每次只能相邻元素交换, 而希尔排序有h-sorting, h距离的元素进行交换 (h逐渐变小)**



**选择合适的增长序列 (increment sequence)**

- 如Knuth提出的 `3x + 1` 的序列, 1, 4, 13 ... , 直到下一个数字比数组长度都大之后



**时间复杂度**

- 最好: N
- 最坏: 与选择的增长序列有关系



- 希尔排序是**原位**的算法
- **不稳定**的算法 (h-sorting时候, 交换元素时可能越过了相同值的元素)





## 归并排序 (merge sort)

**将数组分为两部分, 采用递归思想将两部分排好序, 接着维护两个指针, 将两个排好序的子数组合并成为一个新数组**



**时间复杂度**

`NlgN`, 其中`NlgN`次比较, `NlgN`成正比的数组访问



**空间复杂度**

`O(N)`



- 归并排序不是**原位**的算法
- **稳定的**算法

- 当数组长度较小时, 考虑采用其他排序方法







## 快速排序 (quick sort)

**洗牌后, 选择第一个元素为基准, 对其余元素进行划分, 划分后, 对子数组采用相同算法进行划分**



**复杂度**

- 最优情况:  当每次选择的元素都恰好为中位数时, 复杂度 `NlgN`

- 最差情况: 每次选择的元素都恰好为最大 (或最小) 时, 复杂度 `N * N` (N次, 每次复杂度N)

**洗牌是保证performance的关键**





## 堆排序 (heap sort)

**使用数组来表示一个堆**



**过程**

- **自底向上**构建**大根堆** (max-heap)
  - 从第一个非叶子节点开始
  - 对每一个元素采取 **sink** 操作 (沉底到不能沉底为止)
- 依次将堆顶元素与堆尾元素交换, 并对新的堆顶元素进行沉底操作

- 最终形成**升序**的数组



**复杂度**

能保证`NlgN`的复杂度



- 堆排序是**原位**算法
- **不稳定**





## Knuth 洗牌 (Knuth Shuffle)

**在第i次迭代中, 每次从[0, i]中选出一个索引, 并与a[i]交换**



**复杂度**

`N`, 线性时间