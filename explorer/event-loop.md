# Event Loop

- js时单线程的语言
- js分为同步任务和异步任务，所有的同步任务都在主线程上执行
- 另外存在着一个任务队列，只要异步任务又了结果，便在任务队列里面加入一个事件
- 当主线程的同步任务都执行完了，这个时候会去读区任务队列，依次把他们扔到主线程中执行
- 这个过程不断循环，构成了js的时间循环机制



## 浏览器中js执行线程

- GUI渲染线程
- js引擎线程
- 定时器触发线程
- 异步http请求线程





## 为什么JavaScript是单线程

- 浏览器脚本语言, 多线程会带来问题/



## 事件循环 (Event Loop)

#### 机制

- 浏览器环境只能有一个事件循环
- 事件循环可以有多个任务队列



#### 循环过程

1. 浏览器执行一个macro-task

2. 浏览器取出micro-task的的所有任务
3. 重复1, 2
4. 最终所有队列清空, 代码执行完毕.



**注意**: 第一次执行`<script>`也算是从macro-task中取出一个macro-task.

#### execution stack

**取出的, 正在执行的任务处于execution stack中**



## 任务队列

任务队列包括宏任务队列（macro tasks）和微任务队列（micro tasks）

#### 宏任务队列（macro tasks）

- 包括: script标签，setTimeout，setInterval，setImmediate，I/O, UI rendering



#### 微任务队列（micro tasks）

- 包括: Promise.then，process.nextTick，MutationObserver





## 事件循环

1. 所有的任务都被放在主线程上运行形成一个执行栈（execution context stack），其中的方法入参变量保存在栈内存中，复杂结构对象被保存在堆内存中；
2. 同步任务直接执行并阻塞后续任务等待结束，其中遇到一些异步任务后新开线程去执行该任务（如定时器触发线程，异步http请求线程等），异步任务执行完返回结果之后就把回调事件加入到任务队列
3. 当执行栈所有任务执行完之后，会到任务队列里提取所有的微任务队列执行完
4. 一次循环结束，GUI渲染线程接管，重新渲染页面
5. 执行栈到宏任务队列提取一个事件执行，从第2步开始重复执行